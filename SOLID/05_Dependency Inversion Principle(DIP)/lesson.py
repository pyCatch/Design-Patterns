# DIP - принцип инверсии зависимостей
# Этот принцип не имеет прямого отношения к внедрению зависимостей
# Идея:
#     - высокоуровневые классы (или модули) не должны напрямую зависеть от низкоуровневых модулей,
#     - они должны зависеть от абстракций, посути, мы должны зависеть от интерфейса, а не от конкретных реализации.
# В Python есть "утиная" типизация, поэтому мы можем менять один на другой, просто подставив другой класс с таким же
# интерфейсом, но принято указывать интерфейс явно, что бы клиенты, работающие с вашим кодом,
# могли точно понимать что происходит
# Рассмотрим пример:
#     - предположим что мы проводим гениалогическое исследование, которое будет определять отношение между 2мя людьми
from abc import abstractmethod
from enum import Enum


class Relationship(Enum):
    PARENT = 0
    CHILD = 1
    SIBLING = 2


class Person:
    def __init__(self, name):
        self.name = name


# 1
class RelationshipBrowser:
    @abstractmethod
    def find_all_children_of(self, name):
        pass


# В первую очередь нам необходим какой то низкоуровневый модуль (модуль со всеми деталями реализации,
# всей семантикой хранения, и всем другим что нужно для хранения отношений между разными людьми)
class Relationships(RelationshipBrowser):
    """В этом классе будем хранить все отношения"""

    def __init__(self):
        self.relations = []

    def add_parent_and_child(self, parent, child):
        self.relations.append(
            (parent, Relationship.PARENT, child)
        )
        self.relations.append(
            (child, Relationship.CHILD, parent)
        )

    # 1
    def find_all_children_of(self, name):
        for r in self.relations:
            if r[0].name == 'John' and r[1] == Relationship.PARENT:
                yield r[2].name
        # Это лучше того, что мы сделали раньше, потому что если мы захотим изменить self.relations = [], то у клиента
        # ничего не сломается


# Очевидно, что это довольно низкоуровневое хранилище
# Что бы нарушить принцип инверсии зависимостей мы, для начала, определим высокоуровневый модуль.
# Модуль высокого уровня не должен заботиться о том, как на самом деле это все хранится.
class Research:
    # def __init__(self, relationships):
    #     relations = relationships.relations
    #     for r in relations:
    #         if r[0].name == 'John' and r[1] == Relationship.PARENT:
    #             print(f'John has a child called {r[2].name}')
    # 2
    def __init__(self, browser):
        for p in browser.find_all_children_of('John'):
            print(f'John has a child called {p}')

# Этот код хороший, с точки зрения работоспособности


parent = Person('John')
child1 = Person('Chris')
child2 = Person('Matt')

relationships = Relationships()
relationships.add_parent_and_child(parent, child1)
relationships.add_parent_and_child(parent, child2)

Research(relationships)

# Может показаться, что все впорядке, все работает исправно.
# Но здесь есть большая проблема:
#   - relations - это, по своей сути, способ хранения отношений в модуле Relationship.
#     Сейчас это список (self.relations = []), но представим, что мы решили использовать не список, а что то другое.
#     Мб словарь, или какую то другую специальную структуру хранения данных. В этом случае получается, что мы
#     обращаемся к механизму внутреннего хранилища модля Relationships, который является модулем низкого уровня в нашем
#     модуле высокого уровня. Это плохо! Потому что мы не можем изменить это(self.relations = []) на что то другое.
#     Мы не можем изменить список на словарь, потому что код перестанет работать. Этого мы хотим избежать.
#     Если у нас есть зависимость от реализации хранилища, лучше предоставить какие то вспомогательные методы прямо
#     внутри низкоуровневого модуля, для выполнеия поиска(в нашем примере). Потому что если мы изменим реализацию
#     хранилища, поиск будет выглять совершенно иначе.
# Как исправить ситуацию?
#   - мы можем определить интефейс для низкоуровневого модуля (помним, что Relationships не должен зависить от конкретной
#     реализации, а должен зависеть от какой то абстракции, которые могут быть различны) (#1)

# Далее, нам нужно решить что делать с конструктором Research, с учетом нашего рефакторинга (#1) -> #2

# Подведем итог:
# Research - это модуль высокого уровня
# Relationships - низкоуровневый модуль, так как имеет дело с хранением (хранение - обязанность низкого уровня)
#   Если мы захотим изменить список хранения на БД, то мы спокойно можем изменить этот модуль, и не трогать модули
#   высокого уровня.
# Это и есть цель принципа инверсии зависимостей.
# Вместо того, что бы напрямую зависть от низкоуровнего модуля, мы создаем интерфейс RelationshipBrowser.
# Конечно же если удалить RelationshipBrowser все будет работать благодаря утиной типизации, но такой доход очень
# удобен, потому что c наличием интерфейса, связи между объектами становятся более явными!
# Допустим мы используем для хранения реальную БД. Для модульного тестирования мы не захотим использовать реальную базу
# данных, а захотим создать какое то другое хранилище. Для этого можно унаследовать класс FakeRelationships от нашего
# интерфейса и реализовать функционал такоим образом, что бы все данные будет лежать в оперативной памяти.
